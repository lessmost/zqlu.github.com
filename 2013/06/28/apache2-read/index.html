<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Apache Http Sever 代码阅读 | zqlu&#39;s notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Preface前一段时间，由于实验室的事情需要看一下Apache HTTP Server的源代码，在看的过程中自己就记了一些笔记，这里整理一下传上来，不过代码没有看完，之有其中一部分的笔记。 HooksApache2中一个模块可以输出hook，其他的模块可以使用这个hook，hook的输出者需要声明和实现hook，提供hook函数，调用这个hook；hook的使用者则使用hook函数注册自己的函数">
<meta property="og:type" content="article">
<meta property="og:title" content="Apache Http Sever 代码阅读">
<meta property="og:url" content="https://zqlu.github.io/2013/06/28/apache2-read/index.html">
<meta property="og:site_name" content="zqlu&#39;s notes">
<meta property="og:description" content="Preface前一段时间，由于实验室的事情需要看一下Apache HTTP Server的源代码，在看的过程中自己就记了一些笔记，这里整理一下传上来，不过代码没有看完，之有其中一部分的笔记。 HooksApache2中一个模块可以输出hook，其他的模块可以使用这个hook，hook的输出者需要声明和实现hook，提供hook函数，调用这个hook；hook的使用者则使用hook函数注册自己的函数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2013-06-28T22:49:18.000Z">
<meta property="article:modified_time" content="2021-03-01T21:09:57.417Z">
<meta property="article:author" content="zqlu">
<meta property="article:tag" content="http">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="zqlu&#39;s notes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-151328471-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zqlu&#39;s notes</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zqlu.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-apache2-read" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/28/apache2-read/" class="article-date">
  <time datetime="2013-06-28T22:49:18.000Z" itemprop="datePublished">2013-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenSource/">OpenSource</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Apache Http Sever 代码阅读
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface<a id="orgheadline1"></a></h1><p>前一段时间，由于实验室的事情需要看一下Apache HTTP Server的源代码，在<br>看的过程中自己就记了一些笔记，这里整理一下传上来，不过代码没有看<br>完，之有其中一部分的笔记。</p>
<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks<a id="orgheadline5"></a></h1><p>Apache2中一个模块可以输出hook，其他的模块可以使用这个hook，hook的输<br>出者需要声明和实现hook，提供hook函数，调用这个hook；hook的使用者则使<br>用hook函数注册自己的函数，这样注册的函数就会在适当的时候被调用。</p>
<h2 id="Hooks的实现"><a href="#Hooks的实现" class="headerlink" title="Hooks的实现"></a>Hooks的实现<a id="orgheadline2"></a></h2><p>每一个hook都由宏 <code>AP_DECLARE_HOOK</code> 声明的，首先看看 <code>AP_DECLARE_HOOK</code><br>这个宏是怎么定义的。</p>
<pre><code>/**
 * Declare a hook function
 * @param ret The return type of the hook
 * @param name The hook&apos;s name (as a literal)
 * @param args The arguments the hook function takes, in brackets
 */
#define AP_DECLARE_HOOK(ret, name, args) \
  APR_DECLARE_EXTERNAL_HOOK(ap, AP, ret, name, args)</code></pre><p>宏 <code>APR_DECLARE_EXTERNAL_HOOK</code> 是在apr-utils中定义。下面来看一下<br><code>APR_DECLARE_EXTERNAL_HOOK</code> 的实现。</p>
<pre><code>/* macro to declare the hook correctly */
#define APR_DECLARE_EXTERNAL_HOOK(ns, link, ret, name, args) \
  typedef ret ns##_HOOK_##name##_t args; \
  link##_DECLARE(void) ns##_hook_##name(ns##_HOOK_##name##_t *pf, \
                                       const char * const *aszPre, \
                                       const char * const *aszSucc, \
                                       int nOrder); \
  link##_DECLARE(ret) ns##_run_##name args; \
  APR_IMPLEMENT_HOOK_GET_PROTO(ns, link, name); \
  typedef struct ns##_LINK_##name##_t \
  { \
  ns##_HOOK_##name_t *pFunc; \
  const char *szName; \
  const char * const *aszPredecessors; \
  const char * const *aszSuccessors; \
  int nOrder; \
  } ns##_LINK_##name##_t;</code></pre><p>宏首先定义一个函数类型 <code>ns##_HOOK_##name_t</code> （定义的方式比较特别，<br>和一般使用的函数指针貌似有点差别:(，）; 然后定义了一个函数<br><code>ns##_hook_##name</code> ，使用这个函数就可以向这个hook注册一个函数了，注<br>册的函数的原型就由 <code>ns##_HOOK_##name##_t</code> 定义了。宏同样申明了函数<br><code>ns##_run_##name</code> 。</p>
<p>下面看一下宏 <code>APR_IMPLEMENT_HOOK_GET_PROTO</code></p>
<pre><code>/* macro to return the prototype of the hook function */
#define APR_IMPLEMENT_HOOK_GET_PROTO(ns, link, name) \
  link##_DECLARE(apr_array_header_t *) ns##_hook_get_##name(void)</code></pre><p>所以宏 <code>APR_IMPLEMENT_EXTERNAL_HOOK</code> 还声明了一个函数<br><code>ns##_hook_get_##name</code> 。</p>
<p>最后宏 <code>APR_IMPLEMENT_EXTERNAL_HOOK</code> 定义了结构体<br><code>ns##_LINK_##name##_t</code> 。</p>
<p>上面介绍了hook的声明， <code>AP_DECLARE_HOOK</code> 宏声明一个hook，宏要求三个<br>参数：hook函数的返回值类型 <code>ret</code> ，hook函数的名称 <code>name</code> 和hook函数<br>的参数列表 <code>args</code> 。该宏出现在头文件中以供其他函数使用被定义的hook。<br>以hook <code>header_parser</code> 为例， <code>header_parser</code> 的声明在<br><code>include/http_config.h</code> 文件中。 <code>AP_DECLARE_HOOK(int,
   header_parser, (request_rec *r))</code> 一共做了几件事呢：<br>\#+ <a id="orgtarget1"></a></p>
<ul>
<li><code>typedef int ap_HOOK_header_parser_t (request_rec *r);</code><br>定义了一个类型ap_HOOK_header_parser_t，它是一个函数原型，返回值为<br>int，参数为request_rec *r。</li>
<li><code>void ap_hook_header_parser(...)</code><br>声明了函数 <code>ap_hook_header_parser</code> ，返回类型为 <code>void</code> ，参数为<br><code>ap_HOOK_header_parser_t *pf</code> ,<br><code>const char * const *aszPre</code> ,<br><code>const char * const *aszSucc</code> ,<br><code>int nOrder</code> 。</li>
<li><code>int ap_run_header_parser(...)</code><br>声明了函数 <code>ap_run_header_parser</code> ，返回类型为 <code>int</code> ，参数为<br><code>request_rec *r</code> 。</li>
<li><code>apr_array_header_t * ap_hook_get_header_parser(void)</code><br>声明了函数 <code>ap_hook_get_header_parser</code> ，返回类型为<br><code>apr_array_header_t *</code> 。</li>
<li><code>struct ap_LINK_header_parser_t</code><br>定义了结构体 <code>ap_LINK_header_parser_t</code> ，其成员有<br><code>ap_HOOK_header_parser_t *</code><br><code>const char *szName</code><br><code>const char * const *aszPredecessors</code><br><code>const char * const *aszSuccessors</code><br><code>int nOrder</code></li>
</ul>
<p>一共是两个数据类型和三个函数原型。</p>
<p>下面来看一个hook的实现。同样以 <code>header_parser</code> 这个hook为例来看hook的<br>实现。</p>
<p><code>header_parser</code> 的实现在 <code>server/config.c</code> 里面：</p>
<pre><code>APR_HOOK_STRUCT(
    APR_HOOK_LINK(header_parser)
    APR_HOOK_LINK(pre_config)
    APR_HOOK_LINK(post_config)
    APR_HOOK_LINK(open_logs)
    APR_HOOK_LINK(child_init)
    APR_HOOK_LINK(handler)
    APR_HOOK_LINK(quick_handler)
    APR_HOOK_LINK(optional_fn_retrieve)
    APR_HOOK_LINK(test_config)
                )</code></pre><p>宏 <code>APR_HOOK_STRUCT</code> 和 <code>APR_HOOK_LINK</code> 定义在 <code>apr-utils</code> 中：</p>
<pre><code>/* macro to declare the hook structure */
#define APR_HOOK_STRUCT(members) \
  static struct { members } _hooks;

/* macro to link the hook structure */
#define APR_HOOK_LINK(name) \
  apr_array_header_t *link_##name;</code></pre><p>可以看到宏 <code>APR_HOOK_STRUCT</code> 定义了一个 <code>static struct</code> ，即<br><code>_hooks</code> 是一个 <code>static</code> 结构体，它的成员是一个或者多个<br><code>apr_array_header_t *</code> 类型的变量。（注意这个这个结构体是unnamed<br>struct，并且是static的，这样做的好处可以想想；unamed不是<br>anonymous&#x2026; ）</p>
<p>hook  <code>header_parser</code> 在这里就对应着 <code>server/config.c</code> 里面的<br><code>_hooks</code> 结构体里面的 <code>apr_array_header_t *link_header_parser</code> 变量。</p>
<p>通过前面的hook的声明部分，可以知道hook <code>header_paser</code> 的<a href="#orgtarget1">声明</a>声明了<br>三个函数，这三个函数在哪实现的呢？</p>
<p>查看Apache HTTP Server的Development Document，可以知道，httpd里面的<br>hook有两大类：一类是没有返回值的hook，即hook函数返回类型为void；另<br>一类是有返回值的hook，一般是int类型的。</p>
<p>如果hook函数的返回类型是void的，那么所有注册在这个hook上的函数都会<br>被执行，这样的hook是这样实现的：</p>
<pre><code>/**
 * Implement an Apache core hook that has no return code, and
 * therefore runs all of the registered functions. The implementation
 * is called ap_run_&lt;i&gt;name&lt;i&gt;.
 *
 * @param name The name of the hook
 * @param args_decl The declaration of the arguments for the hook, for
 * example &quot;(int x, void *y)&quot;
 * @param args_use The arguments for the hook as used in a call, for
 * example &quot;(x,y)&quot;
 * @note If IMPLEMENTing a hook that is not linked into the Apache
 * core, (e.g. within a dso) see APR_IMPLEMENT_EXTERNAL_HOOK_VOID.
 */
#define AP_IMPLEMENT_HOOK_VOID(name,args_decl,args_use) \
  APR_IMPLEMENT_EXTERNAL_HOOK_VOID(ap,AP,name,args_decl,args_use)

/**
 * Implement a hook that has no return code, and therefore runs all of
 * the registered functions
 *
 * @param ns The namespace prefix of the hook functions
 * @param link The linkage declaration prefix of the hook
 * @param name The name of the hook
 * @param args_decl The declaration of the arguments for the hook
 * @param args_use The names for the argumentsw for the hook
 * @note The link prefix FOO corresponds to FOO_DECLARE() macro, which
 * provide export linkage from the module that IMPLEMENTs the hook,
 * and import linkage from external modules that link to the hook&apos;s
 * module.
 */
#define APR_IMPLEMENT_EXTERNAL_HOOK_VOID(ns,link,args_decl,args_use) \
  APR_IMPLEMENT_EXTERNAL_HOOK_BASE(ns,link,name) \
  link##_DECLARE(void) ns##_run_##name args_decl \
  { \
  ns##_LINK_##name##_t *pHook; \
  int n; \
  if (!_hooks.link_##name) \
    return; \
  pHook = (ns##_LINK_##name##_t *)_hooks.link_##name-&gt;elts; \
  for (n = 0; n &lt; _hooks.link_##name-&gt;nelts; ++n) \
    pHook[n].pFunc args_use; \
  }

/* macro to implement the hook */
#define APR_IMPLEMENT_EXTERNAL_HOOK_BASE(ns,link,name) \
  link##_DECLARE(void) ns##_hook_##name(ns##_HOOK_##name##_t *pf, \
                                        const char * const *aszPre, \
                                        const char * const *aszSucc, \
                                        int nOrder) \
  { \
    ns##_LINK_##name##_t *pHook; \
    if (!_hooks.link_##name) \
    { \
    _hooks.link_##name = apr_array_make(apr_gblobal_pool, \
                                        1, \
                                        sizeof(ns##_LINK_##name##_t)); \
    } \
    pHook = apr_array_push(_hooks.link_##name); \
    pHook-&gt;pFunc = pf; \
    pHook-&gt;aszPredecessors = aszPre; \
    pHook-&gt;aszSuccessors = aszSucc; \
    pHook-&gt;nOrder = nOrder; \
    pHook-&gt;szName = apr_hook_debug_current; \
    if (apr_hook_debug_enabled) \
      apr_hook_debug_show(#name, aszPre, aszSucc); \
  } \
  APR_IMPLEMENT_HOOK_GET_PROTO(ns,link,name)    \
  {                                             \
    return _hooks.link_##name;                  \
  }</code></pre><p>在前面的介绍中，知道 <code>_hooks.link_##name</code> 的类型是<br><code>apr_array_header_t *</code> 类型的，在Apache APR的文档中有很好的说明。</p>
<p>宏 <code>APR_IMPLMENT_EXTERNAL_HOOK_VOID</code> 首先调用宏<br><code>APR_IMPLEMENT_EXTERNAL_HOOK_BASE</code> ,HOOK_BASE宏实现了函数<br><code>ns##_hook_##name</code> 和 函数 <code>ns##_hook_get_##name</code> 。HOOK_VOID然后实现<br>了函数 <code>ns##_run_##name</code> 。这样可以看到，在hook声明过程中申明的三个<br>函数在这里都得到了实现。</p>
<p>函数 <code>ns##_hook_##name</code> 主要是将参数中的hook函数添加到staitc结构体<br>中对应的array中；函数 <code>ns##_hook_get_##name</code> 则用于获取这个array；<br>最后一个函数 <code>ns##_run_##name</code> 则会运行所有这个array中所有的hook函<br>数。</p>
<p>另外一类hook则是有返回值的，这样的hook又可以分为两类，一类是所有注<br>册的hook函数都被执行，另一类则是运行部分注册的hook函数，在循环执行<br>所有注册的hook函数的过程中，第一个不返回 <code>DECLINE</code> 的hook函数终止这<br>个循环并记录其返回值，后面的hook函数则不会被执行，然后将返回值返回<br>给hook的调用者，这样的hook的实现由宏 <code>AP_IMPLEMENT_HOOK_RUN_FIRST</code><br>完成：</p>
<pre><code>/**
 * Implement a hook that runs until a function returns something other
 * than decline. If all functions return decline, the hook runner
 * returns decline. The implemention is called ap_run_&lt;i&gt;name&lt;/i&gt;.
 *
 * @param ret The return type of the hook (and the hook runner)
 * @param name The name of the hook
 * @param args_decl The declaration of the arguments for the hook, for
 * example &quot;(int x, void *y)&quot;
 * @param args_use The arguments for the hook as used in a call for
 * example &quot;(x,y)&quot;
 * @param decline The &quot;decline&quot; return value
 * @return decline or an error.
 * @note If Implementing a hook that is not linked into the Apache
 * core (e.g. within a dso) see APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST.
 */
#define AP_IMPLEMENT_HOOK_RUN_FIRST(ret,name,args_decl,args_use,decline) \
  APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(ap,AP,ret,name,args_decl, \
                                        args_use,decline)

/**
 * Implement a hook that runs until the first function returns
 * something other than the value of decline
 * @param ns The namespace prefix of the hook functions
 * @param link The linkage declaration prefix of the hook
 * @param name The name of the hook
 * @param ret Type to return
 * @param args_decl The declaration of the argument for the hook
 * @param args_use The name for the arguments for the hook
 * @param decline Decline value
 * @note The link prefix FOO corresponds to FOO_DECLARE() macros,
 * which provide export linkage from the module that IMPLEMNTs the
 * hook, and import linkage from external modules that link to the
 * hook&apos;s module.
 */
#define APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(ns,link,ret,name, \
                                              args_decl, args_use, \
                                              decline) \
  APR_IMPLEMENT_EXTERNAL_HOOK_BASE(ns,link,name) \
  link##DECLARE(ret) ns##_run_##name args_decl \
  { \
  ns##_LINK_##name##_t *pHook; \
  int n; \
  ret rv; \
  \
  if (!_hooks.link_##name) \
    return decline; \
  \
  pHook = (ns##_LINK_##name##_t *)_hooks.link_##name-&gt;elts; \
  for (n = 0; n &lt; _hooks.link_##name-&gt;nelts; ++n) \
  { \
  rv = pHook[n].pFunc args_use; \
  if (rv != decline) \
    return rv; \
  } \
  return decline; \
  }</code></pre><p>可以看到， <code>AP_IMPLEMNET_HOOK_RUN_FIRST</code> 宏的区别只是实现的函数<br><code>ns##_run_##name</code> 不同：在循环执行所有注册hook函数的过程中，当遇到<br>第一个返回值不为decline的hook函数后，循环就终止了，后面的hook函数就<br>不会被执行了；其余的函数的实现则和void类型hook是一样的。</p>
<p>有返回值的Hook的另外一种是所有注册的hook函数都会被执行，直到遇到错<br>误或者全部执行完了。这类hook的实现是由宏<br><code>AP_IMPLEMENT_HOOK_RUN_ALL</code> 完成的：</p>
<pre><code>/**
 * Implement an Apache core hook that runs until one of the functions
 * returns something other than ok or decline. The return valie is
 * then returned from the hook runner. If the hooks run to completion,
 * then ok is returned. Note that if no hooks runs it would probably
 * be more correct to return decline, but this currently does not do
 * so. The implemention is called ap_run_&lt;i&gt;name&lt;/i&gt;.
 *
 * @param ret The return type of the hook (and the hook runner)
 * @param name The name of the hook
 * @param args_decl The declaration of the arguments for the hook, for
 * example &quot;(int x, void *y)&quot;
 * @param ok The &quot;ok&quot; return value
 * @param decline The &quot;decline&quot; return value
 * @return ok, decline, or an error
 * @note If IMPLEMENTing a hook that is not linked into the Apache
 * core, (e.g. within a dso) see APR_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL.
 */
#define AP_IMPLEMENT_HOOK_RUN_ALL(ret,name,args_decl,args_use, \
                                  ok,decline) \
  APR_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL(ap,AP,ret,name,args_decl, \
                                      args_use,ok,decline)

/** FIXME: note that this returns ok when noting is run. I suspect it
 * should really return decline, but that breaks Apache currently - Ben
 */
/**
 * Implement a hook that runs until one of the functions returns
 * something other than OK or DECLINE
 * @param ns The namespace prefix of the hook functions
 * @param link The linkage declaration prefix of the hook
 * @param ret Type to return
 * @param name The name of the hook
 * @param args_decl The declaration of the arguments for the hook
 * @param args_use The names for the arguments for the hook
 * @param ok Success value
 * @param decline Decline value
 * @note The link prefix FOO corresponds to FOO_DECLARE() macros,
 * which provide export linkage from the module that IMPLEMENTs the
 * hook, and import linkage from external modules that lik to the
 * hook&apos;s module.
 */
#define APR_IMPLEMNET_EXTERNAL_HOOK_RUN_ALL(ns,link,ret,name, \
                                            args_decl,args_use, \
                                            ok,decline) \
  APR_IMPLEMNET_EXTERNAL_HOOK_BASE(ns,link,name) \
  link##_DECLARE(ret) ns##_run_##name args_decl \
  { \
  ns##_LINK_##name##_t *pHook; \
  int n; \
  ret rv; \
  \
  if (!_hooks.link_##name) \
    return ok; \
  \
  pHook = (ns##_LINK_##name##_t *)_hooks.link_##name-&gt;elts; \
  for (n = 0; n &lt; _hooks.link_##name-&gt;nelts; ++n) \
  { \
  rv = pHook[n].pFunc args_use; \
  if (rv != ok &amp;&amp; rv != decline) \
    return rv; \
  } \
  return ok; \
  }</code></pre><p>宏 <code>APR_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL</code> 和宏<br><code>APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST</code> 很相似，都需要检查注册函数<br>执行的返回值，只不过前者是在错误情况（返回值既不为ok也不是decline）<br>下终止循环，而后者是在非decline情况下就终止了循环；注意，前者这里有<br>一个FIXME标注，在没有hook函数被执行的情况下，前者仍然是返回ok的，这<br>和后者的返回decline是不同的。</p>
<h2 id="Optional-Hook"><a href="#Optional-Hook" class="headerlink" title="Optional Hook"></a>Optional Hook<a id="orgheadline3"></a></h2><p>Apache2中除了有Hook之外，还有一类Optional hook，还没有仔细研究。</p>
<h2 id="Apache2中的hook"><a href="#Apache2中的hook" class="headerlink" title="Apache2中的hook"></a>Apache2中的hook<a id="orgheadline4"></a></h2><ol>
<li><p>access_checker</p>
<pre><code>/* file: include/http_request.c 331 */
/**
 * This hook is used to apply additional access control to this
 * resource. It runs *before* a user is authenticated, so this hook is
 * really to apply additional restrictions independent of a user. It
 * also runs independent of &apos;Require&apos; directive usage.
 *
 * @param r The current request
 * @param OK, DECLINE, or HTTP_...
 */
AP_DECLARE_HOOK(int, access_checker, (request_rec *r))

/* file: server/request.c 76 */
AP_IMPLEMENT_HOOK_RUN_ALL(int,access_checker,
                          (request_rec *r),
                          (r),
                          DECLINE)</code></pre></li>
<li><p>auth_checker</p>
<pre><code>/* file: include/http_request.h 344 */
/**
 * This hook is used to check to see if the resource beging requested
 * is available for the authenticated user (r-&gt;user and
 * r-&gt;ap_auth_type). It runs after the access_checker and
 * check_user_id hooks. Note that it will *only* be called if Apache
 * determines that access control has been applied to this resource
 * (though a &apos;Require&apos; directive).
 *
 * @param r The current request
 * @return OK, DECLINE, or HTTP_...
 */
AP_DECLARE_HOOK(int, auth_checker, (request_rec *r))

/* file: server/request.c 78 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int,auth_checker,
                            (request_rec *r),
                            (r),
                            DECLINE)</code></pre></li>
<li><p>check_user_id</p>
<pre><code>/* file: include/http_request.h 300 */
/**
 * This hook is used to analyse the request headers, authenticate the
 * user, and set the user information in the request record (r-&gt;user
 * and r-&gt;ap_auth_type). This hook is only run when Apache determines
 * that authentication/authorization is required for this resource (as
 * determined by the &apos;Require&apos; directive). It runs after the
 * access_checker hook, and before the auth_checker hook.
 *
 * @param r The current request
 * @return OK, DECLINE, or HTTP_...
 */
AP_DECLARE_HOOK(int,check_user_id, (request_rec *r))

/* file: server/request.c 70 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int,check_user_id,
                            (request_rec *r),
                            (r),
                            DECLINE)</code></pre></li>
<li><p>child_init</p>
<pre><code>/* file: include/http_config.h 1022 */
/**
 * Run the child_init functions for each module
 * @param pchild The child pool
 * @param s The list of server_recs in this server
 */
AP_DECLARE_HOOK(void, child_init, (apr_pool_t *pchild, server_rec *s))

/* file: server/config.c 153 */
AP_IMPLEMENT_HOOK_VOID(child_init,
                       (apr_pool_t *pchild, server_rec *s),
                       (pchild, s))</code></pre></li>
<li><p>create_connection</p>
<pre><code>/* file: include/http_connection.h 94 */
/**
 * create_connection is a RUN_FIRST hook which allows modules to
 * create connections. In general, you should not install filters with
 * the create_connection hook. If you require vhost configuration
 * information to make filter installation decisions, you must use the
 * pre_connection or install_network_transport hook. This hook should
 * close the connection if it encounters a fatal error condition.
 *
 * @param p The pool from which to allocate the connection record
 * @param server The server record to create the connection too.
 * @param csd The socket that has been accepted
 * @param conn_id A unique identifier for this connection. The ID only
 * needs to be unique at that time, not forever.
 * @param sbh A handle to scoreboard information for this connection.
 * @param alloc The bucket allocator to use for all bucket/bridge
 * creations
 * @return An allocated connection record or NULL
 */
AP_DECLARE_HOOK(conn_rec *, create_connection,
                (apr_pool_t *p, server_rec *server, apr_socket_t *csd,
                 long conn_id, void *sbh, apr_bucket_alloc_t *alloc))

/* file: server/connection.c 40 */
AP_IMPLEMENT_HOOK_RUN_FIRST(conn_rec *,create_connection,
                            (apr_pool_t *p, server_rec *server, apr_socket_t *csd, long conn_id, void *sbh, apr_bucket_alloc_t *alloc),
                            (p, server, csd, conn_id, sbh, alloc),
                            NULL)</code></pre></li>
<li><p>create_request</p>
<pre><code>/* file: include/http_request.h 261 */
/**
 * Gives modules a chance to create their request_config entry when
 * the request is created.
 * @param r The current request
 * @ingroup hooks
 */
AP_DECLARE_HOOK(int, create_request, (request_rec *r))

/* file: server/request.c 81 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, create_request,
                          (request_rec *r),
                          (r),
                          OK, DECLINE)</code></pre></li>
<li><p>default_port</p>
<pre><code>/* file: include/http_protocol.h */
/**
 * Return the default port from the current request
 * @param r The current request
 * @return The current port
 */
AP_DECLARE_HOOK(apr_port_t, default_port, (const request_rec *r))

/* file: server/protocol.c */
AP_IMPLEMENT_HOOK_RUN_FIRST(unsigned short,default_port,
                            (const request_rec *r),
                            (r),
                            0)</code></pre></li>
<li><p>error_log</p>
<pre><code>/* file: include/http_log.h 350 */
/**
 * hook method to log error messages
 * @ingroup hooks
 * @param file The file in which this function is called
 * @param line The line number on which the function is called
 * @param level The level of the this error message
 * @param status The status code from the previous command
 * @param s The server which we are logging for
 * @param r The request which we are logging for
 * @param pool Memeory pool to allocate from
 * @param errstr Message to log
 */
AP_DECLARE_HOOK(void, error_log, (const char *file, int line,
                                  int level, apr_status_t status,
                                  const server_rec *s,
                                  const request_rec *r,
                                  apr_pool_t *pool,
                                  const char *errstr))

/* file: server/log.c 1116 */
AP_IMPLEMENT_HOOK_VOID(error_log,
                       (const char *file, int line, int level,
                        apr_status_t status, const server_rec *s,
                        const request_rec *r, apr_pool_t *pool,
                        const char *errstr), (file, line, level,
                                              status, s, r, pool,
                                              errstr))</code></pre></li>
<li><p>fatal_exception</p>
<pre><code>/* file: include/ap_mpm.h 183 */
AP_DECALRE_HOOK(int, fatal_exception, (ap_exception_info_t *ei))

/* file: server/mpm_common.c 67 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, fatal_exception,
                          (ap_exception_info_t *ei), (ei),
                          OK, DECLINE)</code></pre></li>
<li><p>fixups</p>
<pre><code>/* file: include/http_request.h 309 */
/**
 * Allows modules to perform module-sepcific fixing of header
 * fields. This is invoked just before any content-handler
 * @param r The current request
 * @return OK, DECLINE, or HTTP_...
 */
AP_DECLARE_HOOK(int, fixups, (request_rec *r))

/* file: server/request.c 72 */
AP_IMPLEMENT_HOOK_RUN_ALL(int,fixups,
                          (request_rec *r), (r),
                          OK, DECLINE)</code></pre></li>
<li><p>get_mgmt_items</p>
<pre><code>/* file: include/http_core.h 685 */
/**
 * This hook provides a way for modules to provide mterics/statics
 * about their operational status.
 *
 * @param p A pool to use to create entries in the hash table
 * @param val The name of the paramter(s) that is wanted. This is
 * tree-structured would be in the form (&apos;*&apos; is all the tree,
 * &apos;module.*&apos; all of the module, &apos;module.foo.*&apos;, or &apos;module.foo.bar&apos;)
 * @param ht The hash table to store the result. Keys are item names,
 * and the value point to ap_mgmt_item_t strutures.
 * @ingroup hooks
 */
AP_DECLARE_HOOK(int, get_mgmt_items,
                (apr_pool_t *p, const char *val, apr_hash_t *ht))

/* file: server/core.c 76 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, get_mgmt_items,
                          (apr_pool_t *p, const char *val, apr_hash_t *ht),
                          (p, val, ht),
                          OK, DECLINE)</code></pre></li>
<li><p>get_suexec_identity</p>
<pre><code>/* file: os/unix/unixd.h */
AP_DECLARE_HOOK(ap_unix_identity_t *, get_suexec_identiy, (const request_rec *r))

/* file: os/unix/unixd.c 344 */
AP_IMPLEMENT_HOOK_RUN_FIRST(ap_unix_identity_t *, get_suexec_identity,
                            (const request_rec *r), (r),
                            NULL)</code></pre></li>
<li><p>handler</p>
<pre><code>/* file: include/http_config.h 1029 */
/**
 * Run the handler function for each module
 * @param r The request_rec
 * @remark non-wildcard handlers should HOOK_MIDDLE, wildcard HOOK_LAST
 */
AP_DECLARE_HOOK(int, handler, (request_rec *r))

/* file: server/config.c 157 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int, handler, (request_rec *r),
                            (r), DECLINE)</code></pre></li>
<li><p>header_parser</p>
<pre><code>   #+ &lt;a id=&quot;orgtarget2&quot;&gt;&lt;/a&gt;

1  /* file: include/http_config.h 975 */
2  /**
3   * Run the header parser functions for each module
4   * @param r The current request
5   * @return OK or DECLINED
6   */
7  AP_DECLARE_HOOK(int, header_parser, (request_rec *r))

/* file: server/config.c 79 */
AP_IMPLEMENT_RUN_ALL(int, header_parser,
                     (request_rec *r),
                     (r),
                     OK, DECLINE)</code></pre></li>
<li><p>http_scheme</p>
<pre><code>/* file: include/http_protocol.h 592 */
/**
 * This hook allows modules to retrieve the http scheme for a
 * request. This allows Apache modules to easily extend the schemes
 * that Apache understands
 * @param r The current request
 * @return The http scheme from the request
 */
AP_DECLARE_HOOK(const char *, http_scheme, (const request_rec *r))

/* file: server/protocol.c 1698 */
AP_IMPLEMENT_HOOK_RUN_FIRST(const char *, http_scheme,
                            (const request_rec *r),
                            (r),
                            NULL)</code></pre></li>
<li><p>insert_error_filter</p>
<pre><code>/* file: include/http_protocol.h 45 */
/**
 * This hook allows modules to insert filters for the current error
 * response
 * @param r The current request
 * @ingroup hooks
 */
AP_DECLARE_HOOK(void, insert_error_filter, (request_rec *r))

/* file: modules/http/http_protocol.c 148 */
AP_IMPLEMENT_HOOK_VOID(insert_error_filter, (request_rec *r), (r))</code></pre></li>
<li><p>insert_filter</p>
<pre><code>/* file: include/http_request.h 351 */
/**
 * This hook allows modules to insert filters for the current request
 * @param r The current request
 */
AP_DECLARE_HOOK(void, insert_filter, (request_rec *r))

/* file: server/request.c 80 */
AP_IMPLEMENT_HOOK_VOID(insert_filter, (request_rec *r), (r))</code></pre></li>
<li><p>log_transaction</p>
<pre><code>/* file: include/http_protocol.h 584 */
/**
 * This hook allows modules to preform any module-specific logging
 * activities over and above the normal server things.
 * @param r The current request
 * @return OK, DECLINE, or HTTP_...
 */
AP_DECLARE_HOOK(int, log_transaction, (request_rec *r))

/* file: server/protocol.c 1696 */
AP_IMPLEMENT_HOOK_RUN_ALL(int,log_transaction,
                          (request_rec *r), (r),
                          OK, DECLINE)</code></pre></li>
<li><p>map_to_storage</p>
<pre><code>/* file: include/http_request.h 286 */
/**
 * This hook allow modules to set the per_dir_config based on their
 * own context (such as &quot;&lt;proxy&gt;&quot; sections) and the responds to
 * contextless requests such as TRACE that need no security or
 * filesystem mapping.
 * @param r The current request
 * @return DONE or (HTTP_) if this contextless request was just
 * fulfilled (such as TRACE), OK if this is not a file, or DECLINE  if
 * this is a file.
 * The core map_to_strorage (HOOK_RUN_REALLY_FIRST) will
 * directory_walk and file_walk the r-&gt;filename.
 */
AP_DECLARE_HOOK(int, map_to_strorage, (request_rec *r))

/* file: server/request.c 68 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int,map_to_storage,
                            (request_rec *r), (r),
                            DECLINE)</code></pre></li>
<li><p>monitor</p>
<pre><code>/* file: include/mpm_common.h 379 */
AP_DECLARE_HOOK(int, monitor, (apr_pool_t *p))

/* file: server/mpm_common.c 74 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, monitor,
                          (apr_pool_t *p),
                          (p),
                          OK, DECLINE)</code></pre></li>
<li><p>open_logs</p>
<pre><code>/* file: include/http_config.h 1014 */
/**
 * Run the open_logs function for each module
 * @param pconf The config pool
 * @param plog The logging streams pool
 * @param ptemp The temporary pool
 * @param s The list of server_recs
 * @return OK or DECLINED on success anything else is a error
 */
AP_DECLARE_HOOK(int, open_logs, (apr_pool_t *pconf, apr_pool_t *plog,
                                 apr_pool_t *ptemp, server_rec *s))

/* file: server/config.c 148 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, open_logs,
                          (apr_pool_t *pconf, apr_pool_t *plog,
                           apr_pool_t *ptemp, server_rec *s),
                          (pconf, plog, ptemp, s),
                          OK, DECLINE)</code></pre></li>
<li><p>optional_fn_retrieve</p>
<pre><code>/* file: include/http_config.h 1049 */
/**
 * Retrieve the optional functions for each module.
 * This is run immediately before the server starts. Optional
 * functions should be registered during the hook registration phase.
 */
AP_DECLARE_HOOK(void, optional_fn_retrieve, (void))

/* file: server/config.c 163 */
AP_IMPLEMENT_HOOK_VOID(optional_fn_retrieve, (void), ())</code></pre></li>
<li><p>post_config</p>
<pre><code>/* file: include/http_config.h 1003 */
/**
 * Run the post_config function for each module
 * @param pconf The config pool
 * @param plog The logging streams pool
 * @param ptemp The temporary pool
 * @param s The list of server_recs
 * @return OK or DECLINED on success anything else is a error
 */
AP_DECLARE_HOOK(int, post_config, (apr_pool_t *pconf, apr_pool_t *plog
                                   apr_pool_t *ptemp, server_rec *s))

/* file: server/config.c 91 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, post_config,
                          (apr_pool_t *pconf, apr_pool_t *plog,
                           apr_pool_t *ptemp, server_rec *s),
                          (pconf, plog, ptemp, s),
                          OK, DECLINE)</code></pre></li>
<li><p>post_read_request</p>
<pre><code>/* file: include/http_protocol.h 576 */
/**
 * post_read_request --- run right after read_request or
 * internal_redirect and not run during any subrequests.
 */
/**
 * This hook allows modules to affect the request immediately after
 * the request has been read, and before any other phases have been
 * processes. This allows modules to make decisions based upon the
 * input header fields
 * @param r The current request
 * @return OK or DECLINE
 */
AP_DECLARE_HOOK(int, post_read_request, (request_rec *r))

/* file: server/protocol.c 1694 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, post_read_request,
                          (request_rec *r), (r),
                          OK, DECLINE)</code></pre></li>
<li><p>pre_config</p>
<pre><code>/* file: include/http_config.h 984 */
/**
 * Run the pre_config function for each module
 * @param pconf The config pool
 * @param plog The logging streams pool
 * @param ptemp The temporary pool
 * @return OK or DECLINED on success anything else is a error
 */
AP_DECLARE_HOOK(int, pre_config, (apr_pool_t *pconf, apr_pool_t *plog,
                                  apr_pool_t *temp))

/* file: server/config.c 82 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, pre_config,
                          (apr_pool_t *pconf, apr_pool_t *plog,
                           apr_pool_t *ptemp),
                          (pconf, plog, ptemp),
                          OK, DECLINE)</code></pre></li>
<li><p>pre_connection</p>
<pre><code>/* file: include/http_connection.h 108 */
/**
 * This hook gives protocol modules an opportunity to set everything
 * up before calling the protocol handler. All pre_connection hooks
 * are run until one returns something other than ok or decline
 *
 * @param c The connection on which the request has been received.
 * @param csd The mechanism on which this connection is to be
 * read. Most times this will be a socket, but it is up to the module
 * that accepts the request to determine the exact type.
 * @return OK or DECLINE
 */
AP_DECLARE_HOOK(int, pre_connection, (conn_rec *C, void *csd))

/* file: server/connection.c 44 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, pre_connection,
                          (conn_rec *c, void *csd),
                          (c, csd),
                          OK, DECLINE)</code></pre></li>
<li><p>pre_mpm</p>
<pre><code>/* file: include/scoreboard.h 212 */
/**
 * Hook for post scoreboard createion, pre mpm.
 * @param p Apache pool to allocate from
 * @param sb_type
 * @return OK or DECLINE on success; anything else is a error
 */
AP_DECLARE_HOOK(int, pre_mpm, (apr_pool_t *p, ap_scoreboard_e sb_type))

/* file: server/scoreboard.c 60 */
AP_IMPLEMENT_HOOK_RUN_ALL(int, pre_mpm,
                          (apr_pool_t *p, ap_scoreboard_e sb_type),
                          (p, sb_type),
                          OK, DECLINE)</code></pre></li>
<li><p>process_connection</p>
<pre><code>/* file: include/http_connection.h 118 */
/**
 * This hook implements different protocols. After a connection has
 * been established, the protocol module must read and serve the
 * request. This function does that for each protocol module. Ths
 * first protocol module to handle the request is the last module run.
 *
 * @param c The connection on which the request has been received.
 * @return OK or DECLINE
 */
AP_DECLARE_HOOK(int, process_connection, (conn_rec *c))

/* file: server/connection.c 43 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int, process_connection,
                            (conn_rec *c), (c),
                            DECLINE)</code></pre></li>
<li><p>quick_handler</p>
<pre><code>/* file: include/http_config.h 1042 */
/**
 * Run the quick handler functions for each module. The quick_handler
 * is run before any other requests hooks are called (location_walk,
 * directory_walk, access checking, et. al.). This hook was added to
 * provide a quick way to server content from a URI keyed cache.
 *
 * @param r The request_rec
 * @param lookup_uri Controls whether the caller actually wants
 * content of not. look up is set when the quick_handler is called out
 * of ap_sub_req_lookup_uri()
 */
AP_DECLARE_HOOK(int, quick_handler, (request_rec *r, int lookup_uri))

/* file: server/config.c 160 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int, quick_handler,
                            (request_rec *r, int lookup),
                            (r, lookup),
                            DECLINE)</code></pre></li>
<li><p>test_config</p>
<pre><code>/* file: include/http_config.h 993 */
/**
 * Run the test_config function for each module; this hook is run
 * only if the server was invoked to test the configuration syntax.
 * @param pconf The config pool
 * @param s The list of server_recs
 */
AP_DECLARE_HOOK(void, test_config, (apr_pool_t *pconf, server_rec *s))

/* file: server/config.c 87 */
AP_IMPLEMENT_HOOK_VOID(test_config,
                       (apr_pool_t pconf, server_rec *s),
                       (pconf, s))</code></pre></li>
<li><p>translate_name</p>
<pre><code>/* file: include/http_request.h 271 */
/**
 * This hook allows modules an opportunity to translate the URI into
 * an actual filename. If no modules do anything special, the server&apos;s
 * default rules will be followed.
 * @param r The current request
 * @return OK, DECLINE, or HTTP_...
 */
AP_DECLARE_HOOK(int, translate_name, (request_rec *r))

/* file: server/request.c 66 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int, transalte_name,
                            (request_rec *r),
                            (r), DECLINE)</code></pre></li>
<li><p>type_checker</p>
<div class="org-center">
    /* file: include/http_request.h 319 */
    /**
     * This routine is called to determine and/or set the various document
     * type information bits, link Content-type (via r->content_type),
     * language, et cetera.
     * @param r The current request
     * @return OK, DECLINE, or HTTP_...
     */
    AP_DECLARE_HOOK(int, type_checker)

<pre><code>/* file: server/request.c 74 */
AP_IMPLEMENT_HOOK_RUN_FIRST(int, type_checker,
                            (request_rec *r),
                            (r),
                            DECLINE)</code></pre></div>

</li>
</ol>
<p>够多吧。。</p>
<h1 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters<a id="orgheadline7"></a></h1><p>Filters是Apache2中的另一个特点，在一般http server中，请求从客户端发<br>送，server接受后直接交给http server处理，http处理后的结果则直接通过<br>网络返回给客户端；但在Apache2中，从客户端发送来的请求，可以被Apache2<br>中的模块处理后，再交于http模块处理请求，http模块处理后返回的结果也不<br>是直接返回给客户端，其他的模块可以先处理http模块的返回结果后，再传给<br>客户端，这就是Apache2中的filters。</p>
<p>模块可以创作input_filter或者output_filter，http请求在被结果后，请求<br>首先被这些input_filter处理，一层层的input_filter处理完成后，在由http<br>模块来处理http请求，http模块的处理结果则首先被output_filter处理，所<br>有的output_filter处理完成后，最后通过网络发送出去。</p>
<p>filters的设计使得某些功能相当容易实现，比如加解密操作，压缩与解压缩<br>操作等等。</p>
<h2 id="filter的使用"><a href="#filter的使用" class="headerlink" title="filter的使用"></a>filter的使用<a id="orgheadline6"></a></h2><p>在模块中，filters需要注册:</p>
<pre><code>/**
 * This function is used to register an output filter with the
 * system. After this registration is performed, then a filter may be
 * added into the filter chian by using ap_add_output_filter() and
 * simply specifying the name. It may also be used as a provider under
 * mod_filter. This is (equivalent to)
 * ap_register_output_filter_protocol with proto_flag=0, and is
 * retained for back-compatibility with 2.0 modules.
 *
 * @param name The name to attach to the filter function
 * @param filter_func The filter function to name
 * @param filter_init The function to call before the filter handlers
 * are invoked
 * @param ftype The type of filter function, either ::AP_FTYPE_CONTENT
 * or ::AP_FTYPE_CONNECTION
 */
AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter(const char *name,
                                                        ap_out_filter_func filter_func,
                                                        ap_init_filter_func filter_init,
                                                        ap_filter_type ftype);

/**
 * This function is used to register an input filter with the
 * system. After this registration is performed, then a filter may be
 * added into the filter chain by using ap_add_input_filter() and
 * simply specifying the name.
 *
 * @param name The name to attach to the filter function
 * @param filter_func The function to call before the filter handlers
 * are invoked
 * @param ftype The type of filter function, either ::AP_FTYPE_CONTENT
 * or ::AP_FTYPE_CONNECTION
 */
AP_DECLARE(ap_filter_rec_t *r) ap_register_input_filter(const char *name,
                                                        ap_in_filter_func filter_func,
                                                        ap_init_filter_func filter_init,
                                                        ap_filter_type ftype);</code></pre><p>在filter被注册后，就可以将filter加入到filter chain之中了，加入的方<br>法有有很多。下面两个函数可以将filter添加到filter chain：</p>
<pre><code>/*
 * Add a filter to the current request. Filters are added in a FIFO
 * manner. The first filter added will be the first filter called.
 * @param name The name of the filter to add
 * @param ctx Context data to set in the filter
 * @param r The request to add this filter for (or NULL if it isn&apos;t
 * associated with a request)
 * @param c The connection to add this filter for
 */
AP_DECLARE(ap_filter_t *) ap_add_output_filter(const char *name,
                                               void *ctx,
                                               request_rec *r,
                                               conn_rec *c);

/*
 * Adds a named filter into the filter chain on the specified request record.
 * The filter will be installed with the specified context pointer.
 *
 * Filters added in this way will be always be placed at the end of
 * the filters that have the same type (thus, the filters have the
 * same order as the calls to ap_add_filter). If the current filter
 * chain contains filters from another request, than this filter will
 * be added before those other filters.
 *
 * To re-iterate that last comment. This function is building a FIFO
 * list of filters. Take note of that when adding you filter to the chain.
 *
 * @param name The name of the filter to add
 * @param ctx Context data to provide to the filter
 * @param r The request to add this filter for (or NULL if it isn&apos;t
 * associated with a request)
 * @param c The connection to added the filter for
 */
AP_DECLARE(ap_filter_t *) ap_add_input_filter(const char *name,
                                              void *ctx,
                                              request_rec *r,
                                              conn_rec *c);</code></pre><p>一种方法是首先使用hook insert_filter，向这个hook注册一个hook函数，在函<br>数里决定是否添加filter到filter chain。</p>
<p>源代码modules/experimental/里面有两个最简单的filter示例：<br>mod_case_filter和mode_case_filter_in，这两个filter的功能就是把输出<br>或者输入全部大写化，一个简单的 <code>toupper</code> 操作。</p>
<h1 id="请求的处理"><a href="#请求的处理" class="headerlink" title="请求的处理"></a>请求的处理<a id="orgheadline13"></a></h1><p>这里以hook执行的顺序来解释http请求在Apache2中处理的过程。在accept到<br>一个连接后，首先执行的hook是 <code>create_connection</code> :</p>
<pre><code>/*
 * We now have a connection, so set it up with the appropriate socket
 * options, file descriptors, and read/write buffer.
 */
current_connection = ap_run_create_connection(ptrans, ap_server_conf, csd, my_child_num, sbh, bucket_alloc);</code></pre><p>然后是 <code>pre_connection</code> ，在函数 <code>ap_process_connection</code> 中被调用：</p>
<pre><code>rc = ap_run_pre_connection(c, csd);</code></pre><p>再是 <code>process_connection</code> ，同样是在函数 <code>ap_process_connection</code> 中<br>被调用的：</p>
<pre><code>ap_run_process_connection(c);</code></pre><p>这些hook运行完了，处理就处理完了。</p>
<p>下面看有那些模块都向这些hook注册了hook函数的呢？</p>
<h2 id="create-connection的注册者"><a href="#create-connection的注册者" class="headerlink" title="create_connection的注册者"></a>create_connection的注册者<a id="orgheadline8"></a></h2><p><code>create_connection</code> 是一个RUN_FIRST类型的hook，为什么呢？因为在<br>server/connection.c里面的 <code>create_connection</code> 的实现是这样的:</p>
<pre><code>AP_IMPLEMENT_HOOK_RUN_FIRST(conn_rec *, create_connection,
                            (apr_pool_t *p,
                             server_rec *server,
                             apr_socket_t *csd,
                             long conn_id,
                             void *sbh,
                             apr_bucket_alloc_t *alloc),
                            (p, server, csd, conn_id, sbh, alloc),
                            NULL)</code></pre><p>这最后一个参数是NULL，代表什么意思呢，在前面的hook实现中已经知道了，<br>最后一个参数是 <code>decline</code> 的值，这就说明如果 <code>create_connect</code> 的注册<br>函数如果返回NULL就是返回了decline了，这样下一个hook将继续执行，如果<br>返回的是非NULL，后面的hook就不会被执行的，将直接返回这个值给<br><code>create_connection</code> 的调用者。</p>
<p>下面看看都有谁注册了宏 <code>create_connection</code> 呢？这个只要看谁调用了<br><code>ap_hook_create_connection</code> 就可以了：发现只有已有一个模块core<br>module注册了这个hook：</p>
<pre><code>ap_hook_create_connection(core_create_conn, NULL, NULL,
                          APR_HOOK_REALLY_LAST);</code></pre><p><code>core_create_conn</code> 做的事情就是创建 <code>conn_rec</code> 对象，并填好其中的各<br>个字段，如本地ip，远端ip等等。</p>
<h2 id="pre-connection的注册者"><a href="#pre-connection的注册者" class="headerlink" title="pre_connection的注册者"></a>pre_connection的注册者<a id="orgheadline9"></a></h2><p><code>pre_connection</code> 是一个RUN_ALL类型的hook：</p>
<pre><code>AP_IMPLEMENT_HOOK_RUN_ALL(int, pre_connection,
                          (conn_rec *c, void *csd),
                          (c, csd),
                          OK,
                          DECLINE)</code></pre><p>注册hook <code>pre_connection</code> 的模块就很多了。下面列出version 2.2.21源<br>代码中注册了 <code>pre_connection</code> 的模块：</p>
<ol>
<li><p>core_module<br>core_module(server/core.c)在register hooks的过程中注册了<br><code>pre_connection</code>:</p>
<pre><code>ap_hook_pre_connection(core_pre_connection, NULL, NULL,
                       APR_HOOK_REALLY_LAST);</code></pre><p><code>core_pre_connection</code> 设置了连接的timeout等属性，并添加了一个<br>input_filter和一个output_filter：</p>
<pre><code>ap_add_input_filter_handle(ap_core_input_filter_handle, net, NULL, net-&gt;c);
ap_add_output_filter_handle(ap_core_output_filter_handle, net, NULL, net-&gt;c);</code></pre></li>
<li><p>logio_module<br>logio_module(modules/loggers/mod_logio.c)注册了<br><code>pre_connection</code> :</p>
<pre><code>ap_hook_pre_connection(logio_pre_conn, NULL, NULL, APR_HOOK_MIDDLE);</code></pre><p>函数 <code>logio_pre_conn</code> 同样添加了两个filter到filter chain里面：</p>
<pre><code>ap_add_input_filter(logio_filter_name, NULL, NULL, c);
ap_add_output_filter(logio_filter_name, NULL, NULL, c);</code></pre></li>
<li><p>dumpio_module</p>
<pre><code>  dumpio\_module(modules/debug/mod\_dumpio.c)：

ap_hook_pre_connection(dumpio_pre_conn, NULL, NULL, APR_HOOK_MIDDLE);</code></pre><p>函数 <code>dumpio_pre_conn</code> 根据配置选择是否添加两个filters：</p>
<pre><code>dumpio_conf_t *ptr =
    (dumpio_conf_t *) ap_get_module_config(c-&gt;base_server-&gt;module_config,
                                           &amp;dumpio_module);

if (ptr-&gt;enable_input)
  ap_add_input_filter(&quot;DUMPIO_IN&quot;, NULL, NULL, c);
if (ptr-&gt;enable_output)
  ap_add_output_filter(&quot;DUMPIO_OUT&quot;, NULL, NULL, c);</code></pre></li>
<li><p>ssl_module</p>
<pre><code>  ssl\_module(modules/ssl/mod\_ssl.c)：

ap_hook_pre_connection(ssl_hook_pre_connection, NULL, NULL, APR_HOOK_MIDDLE);</code></pre></li>
<li><p>nwssl_module</p>
<pre><code>  nwssl\_module(modules/arch/netware/mod\_nw\_ssl.c)：

ap_hook_pre_connection(nwssl_pre_connection, NULL, NULL, APR_HOOK_MIDDLE);</code></pre></li>
<li><p>example_module </p>
<pre><code>  示例模块example\_module(modules/experimental/mod\_example.c)：

ap_hook_pre_connection(x_pre_connection, NULL, NULL, APR_HOOK_MIDDLE);</code></pre><p>函数 <code>x_pre_connection</code> 什么也没做，之是简单的log trace一下。</p>
</li>
</ol>
<h2 id="process-connection的注册者"><a href="#process-connection的注册者" class="headerlink" title="process_connection的注册者"></a>process_connection的注册者<a id="orgheadline10"></a></h2><p><code>process_connection</code> 是一个RUN_FIRST类型的hook，在<br>server/connection.c里面：</p>
<pre><code>AP_IMPLEMENT_HOOK_RUN_FIRST(int, process_connection,
                            (conn_rec *r),
                            (c),
                            DECLINE)</code></pre><p>注册 <code>process_connection</code> 的模块有：</p>
<ol>
<li><p>http_module</p>
<pre><code>/*
 * If we are using an MPM that supports Async Connections,
 * use a different processing function
 */
int async_mpm = 0;
if (ap_mpm_query(AP_MPMQ_IS_ASYNC, &amp;async_mpm) == APR_SUCCESS
    &amp;&amp; async_mpm == 1) {
  ap_hook_process_connection(ap_process_http_async_connection,
                             NULL,
                             NULL,
                             APR_HOOK_REALLY_LAST);
}
else {
  ap_hook_process_connection(ap_process_http_connection,
                             NULL,
                             NULL,
                             APR_HOOK_REALLY_LAST);
}</code></pre><p>函数 <code>ap_mpm_query</code> 是每个MPM都必须实现的函数，用于查询MPM的属性，<br>http_module在这里查询了 <code>AP_MPMQ_IS_ASYNC</code> 这个属性，目前在所有<br>的MPM中，只有event这个MPM支持 <code>AP_MPMQ_IS_ASYNC</code> 这个属性，所以<br>这里主要观察函数 <code>ap_process_http_connection</code> :</p>
<p><code>ap_process_http_connection</code> 的主体是一个循环的调用<br><code>ap_read_request</code> :</p>
<pre><code>static int ap_process_http_connection(conn_rec *c)
{
  request_rec *r;
  apr_socket_t *csd = NULL;
  /*
   * Read and process each request found on our connection
   * until no request are left or we decide to close.
   */
  ap_update_child_status(c-&gt;sbh, SERVER_BUSY_READ, NULL);
  while ((r = ap_read_request(c)) != NULL) {
    /* ... loop body before process request ... */
    /* process the request if it was read without error */
    if (r-&gt;status == HTTP_OK)
      ap_process_request(r);
    /* ... loop body after process request ... */
  }

  return OK;
}</code></pre><p>下面看看函数 <code>ap_read_request</code> ：</p>
<pre><code>/* file: server/protocol.c:845 */
request_rec *ap_read_request(conn_rec *conn)
{
  request_rec *r;
  /* ... construct the request_rec object ... */
  r = apr_pcalloc(p, sizeof(request_rec));
  /* set each properties of r */
  /* Must be set before we run create request hook */
  ap_run_create_request(r);

  /* Get the request... */

  ap_add_input_filter_handle(ap_http_input_filter_handle,
                             NULL, r, r-&gt;connection);

  /* ... */

  if ((access_status = ap_run_post_read_request(r))) {
    /* ... */
  }

  ap_run_log_transaction(r);

  /* ... */

  return r;
}</code></pre><p>函数 <code>ap_read_request</code> 又运行了hook create_request和hook<br>post_read_request。</p>
<p>在 <code>ap_read_request</code> 成功且没有发生错误后，就表示请求已经成功的<br>接收到了，然后继续由<br><code>ap_process_request</code> 来处理了，下面接续看函数<br><code>ap_process_request</code> :</p>
<pre><code>/* file: modules/http/http_request.c */
void ap_process_request(request_rec *r)
{
  /* Give quick handlers a shot at serving the request on the fast path,
   * bypassing all of the other Apache hooks.
   */
  if (ap_extended_status)
    ap_time_process_request(r-&gt;connection-&gt;sbh, START_PREQUEST);
  access_status = ap_run_quick_handler(r, 0); /* Not a look-up request
                                               * */
  if (access_status == DECLINE) {
    access_status = ap_process_request_internal(r);
    if (access_status == OK) {
      access_status = ap_invoke_handler(r);
    }
  }

  if (access_status == DONE) {
    /* e.g., something not in storage like TRACE */
    access_status = OK;
  }

  if (access_status == OK) {
    ap_finalize_request_protocol(r);
  }
  else {
    r-&gt;status = HTTP_OK;
    ap_die(access_status, r);
  }

  /*
   * We want to flush the last packet if this isn&apos;t a pipelining
   * connection *before* we start into logging. Suppose that logging
   * cause a DNS lookup to occur, which may have a high latency. If we
   * hold off on this packet, then it&apos;ll appear like the link is
   * stalled when really it&apos;s the application that&apos;s stalled.
   */
  check_pipeline_flush(r);
  ap_update_child_status(r-&gt;connection-&gt;sbh, SERVER_BUSY_LOG, r);
  ap_run_log_transaction(r);
  if (ap_extended_status)
    ap_time_process_request(r-&gt;connection-&gt;sbh, STOP_PREQUEST);
}</code></pre><p>函数 <code>ap_process_request</code> 首先运行了hook quick_handler，然后主要<br>调用了三个函数：<br><code>ap_process_request_internal</code> ， <code>ap_invoke_handler</code> 和<br><code>ap_finalize_request_protocol</code> 。</p>
<p>从Apache2的developer文档中，可以看到函数<br><code>ap_process_request_internal</code> 可以分为下面几个阶段：</p>
<ul>
<li>Request Parsing Phase<br>这阶段的动作有URI的检查，Location Walk，translate name (hook<br>translate_name), map to storage (hook map_to_storage)，Header<br>parse (hook header_parser)。</li>
<li>Security Phase</li>
<li>Preparation Phase<br>这阶段主要运行两个hook：type_checker 和 fixups.</li>
</ul>
<p>上面三个阶段完成后，下面一步就是相应内容的产生，所以fixup就在产<br>生相应内容之前运行的最后一个hook了。<br>函数 <code>ap_invoke_handler</code> 继续完成下面这个阶段：</p>
<ul>
<li><p>Handler Phase<br>这个阶段首先运行hook insert_filter，然后初始化filters，然后运<br>行hook handler：</p>
<pre><code>result = ap_run_handler(r);</code></pre></li>
</ul>
<p><code>ap_process_request</code> 最后调用了函数<br><code>ap_finalize_request_protocol</code> 。</p>
<p>这样这个请求就被处理完成了。</p>
</li>
<li><p>reqtimeout_module</p>
<pre><code>/*
 * mod_reqtimeout needs to be called before ap_process_http_request
 * (which is run at APR_HOOK_REALLY_LAST) but after all other protocol
 * modules. This ensures that it only influences normal http
 * connections and not e.g. mod_ftp. Also, if mod_reqtimeout used the
 * pre_connection hook, it would be insert on mod_proxy&apos;s backend
 * connections.
 */
ap_hook_process_connection(reqtimeout_init, NULL, NULL, APR_HOOK_LAST);</code></pre><p>reqtimeout_module是给Apache2 server提供设置超时的一个模块，提供<br>了很细致的超时控制，如接受http header的超时定时器，接受body的超<br>时定时器等。</p>
<p><code>reqtimeout_init</code> 所做的就是获取配置信息等工作。</p>
</li>
<li><p>echo_module</p>
<pre><code>ap_hook_process_connection(process_echo_connection, NULL,
                           NULL, APR_HOOK_MIDDLE);</code></pre><p>echo_module是什么模块呢？原来Apache的模块中有一类是协议模块，做<br>为http server的Apache2，http_module是必不可少的，此外还有一些协<br>议模块如ftp模块，ftp_module则可以使Apache2变成一个ftp server。<br>echo_module也是一个协议模块，只不过echo_module实现的协议相当简单：<br>echo server，开启echo_module后，telnet到Apache2 server上，<br>echo_module就简单的返回所有接收到的数据。</p>
<p>所以函数 <code>process_echo_connection</code> 就很简单，它首先得到配置，查<br>看echo是否被启动，如果没有启用就返回DECLINE，如果启用了则从接受<br>到的数据中一行行的读取，没读取一行就返回同样的数据给客户端。</p>
</li>
<li><p>example_module</p>
<pre><code>ap_hook_process_connection(x_process_connection, NULL, NULL,
                           APR_HOOK_MIDDLE);</code></pre><p>example_module在前面提到了是Apache2的一个示例模块快，给模块开发者提供一个示<br>范。所以在 <code>x_process_connection</code> 函数中，example_module什么事情<br>也没有做，只是返回DECLINE。</p>
</li>
</ol>
<p>完了。</p>
<h2 id="request-rec结构"><a href="#request-rec结构" class="headerlink" title="request_rec结构"></a>request_rec结构<a id="orgheadline12"></a></h2><p>request_rec是一个庞大的结构</p>
<h3 id="request-time"><a href="#request-time" class="headerlink" title="request_time"></a>request_time<a id="orgheadline11"></a></h3><p>request_time表示接收到这个请求的时间，在函数 <code>read_request_line</code><br>里面被标记上了，它又被 <code>ap_read_request</code> 调用，在上面知道了<br><code>ap_read_request</code> 是 <code>ap_process_connection</code> 的第一步。</p>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes<a id="orgheadline14"></a></h1><ul>
<li>Last update: <span class="timestamp-wrapper"><span class="timestamp">[2011-11-24 Thu 16:46] </span></span></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zqlu.github.io/2013/06/28/apache2-read/" data-id="cklr2sz2f00007woq10rdcic6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/29/clearly-css/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          悦读插件是怎么让网页变得简明和易如阅读的？
        
      </div>
    </a>
  
  
    <a href="/2013/06/28/my-openbox-configuration/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">我的 Openbox 窗口管理器的配置</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Desktop/">Desktop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenSource/">OpenSource</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Visualization/">Visualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Desktop/" rel="tag">Desktop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/" rel="tag">NodeJS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Visualization/" rel="tag">Visualization</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/awk/" rel="tag">awk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Desktop/" style="font-size: 10px;">Desktop</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/NodeJS/" style="font-size: 10px;">NodeJS</a> <a href="/tags/Visualization/" style="font-size: 20px;">Visualization</a> <a href="/tags/awk/" style="font-size: 10px;">awk</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/http/" style="font-size: 10px;">http</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/15/python-service-thing/">[译]我们必须得谈谈 Python、Gunicorn、Gevent 这些事了</a>
          </li>
        
          <li>
            <a href="/2020/04/09/observable-introduction/">Observable 基础介绍</a>
          </li>
        
          <li>
            <a href="/2019/12/26/d3-scale-intro/">d3-scale-intro</a>
          </li>
        
          <li>
            <a href="/2019/11/03/why-use-lowercase-for-filename/">为什么 Google 代码规范推荐使用小写作为文件名</a>
          </li>
        
          <li>
            <a href="/2016/05/10/taobao-nodejs-mirror/">使用淘宝 NodeJS 镜像加速 Electron Node-Sass 的安装速度</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 zqlu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>